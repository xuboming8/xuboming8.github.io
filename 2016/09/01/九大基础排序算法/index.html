<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Hippopmonkey" />



<meta name="description" content="基础排序算法分析与总结插入类排序直接插入排序算法思想：(1)将第i个记录插入到前面i-1个已经排序好的记录中(2)插入过程为依次比较后移，直到找到比第i个记录小的数为止，插入。">
<meta property="og:type" content="article">
<meta property="og:title" content="十三种基础排序算法[置顶]">
<meta property="og:url" content="http://xuboming8.github.io/2016/09/01/九大基础排序算法/index.html">
<meta property="og:site_name" content="臀臀柯基">
<meta property="og:description" content="基础排序算法分析与总结插入类排序直接插入排序算法思想：(1)将第i个记录插入到前面i-1个已经排序好的记录中(2)插入过程为依次比较后移，直到找到比第i个记录小的数为止，插入。">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329094816957-1860272498.jpg">
<meta property="og:image" content="http://img.blog.csdn.net/20150606133020561">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329095145504-1018443290.gif">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160328201132394-577931661.gif">
<meta property="og:image" content="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148493217649.jpg">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160328205313363-2043878119.gif">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329100443676-1647340243.gif">
<meta property="og:image" content="http://img.blog.csdn.net/20150606135844053">
<meta property="og:image" content="http://img.blog.csdn.net/20160519164311224">
<meta property="og:image" content="http://img.blog.csdn.net/20150606134600369">
<meta property="og:image" content="http://img.blog.csdn.net/20150606134622646">
<meta property="og:image" content="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148493184991.png">
<meta property="og:image" content="http://img.blog.csdn.net/20150606133355179">
<meta property="og:image" content="http://img.blog.csdn.net/20150606133543747">
<meta property="og:image" content="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148492044202.png">
<meta property="og:image" content="http://img.blog.csdn.net/20160517150920429">
<meta property="og:image" content="http://img.my.csdn.net/uploads/201210/29/1351511800_4371.jpg">
<meta property="og:image" content="http://img.blog.csdn.net/20150606133653347">
<meta property="og:image" content="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148492107059.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329112223504-109981973.gif">
<meta property="og:image" content="http://images.cnitblog.com/i/175043/201407/140246168184432.jpg">
<meta property="og:image" content="http://images.cnitblog.com/i/175043/201407/141242228816031.png">
<meta property="og:image" content="http://images.cnitblog.com/i/175043/201407/141242472874543.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329112725566-1371714328.jpg">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305151241455-435533779.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305151315580-1475685491.png">
<meta property="og:image" content="http://images.cnitblog.com/i/175043/201407/141258384434292.png">
<meta property="og:updated_time" content="2017-01-21T05:15:43.562Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="十三种基础排序算法[置顶]">
<meta name="twitter:description" content="基础排序算法分析与总结插入类排序直接插入排序算法思想：(1)将第i个记录插入到前面i-1个已经排序好的记录中(2)插入过程为依次比较后移，直到找到比第i个记录小的数为止，插入。">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329094816957-1860272498.jpg">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="臀臀柯基" type="application/atom+xml">



    <link rel="shortcut icon" href="img/favicon.ico">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/white/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>十三种基础排序算法[置顶] | 臀臀柯基</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/15029834412.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Hippopmonkey</a></h1>
        </hgroup>

        
        <p class="header-subtitle">每天都是一个起点，每天都有一点进步，每天都有一点收获!</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="true" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜單</li>
                        <li>標籤</li>
                        
                        <li>友情鏈接</li>
                        
                        
                        <li>關於我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa 新浪微博" href="http://weibo.com/u/5255092020/home" title="新浪微博"></a>
                            
                                <a class="fa GitHub" href="https://github.com/" title="GitHub"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/#signin" title="知乎"></a>
                            
                                <a class="fa 豆瓣" href="https://www.douban.com/" title="豆瓣"></a>
                            
                                <a class="fa 简书" href="http://www.jianshu.com/" title="简书"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACM/">ACM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CCPC/">CCPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LIS/">LIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MST/">MST</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RMQ/">RMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/">STL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ST算法/">ST算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UVA/">UVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm/">acm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/acm-codeforces/">acm & codeforces</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/atcoder/">atcoder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bitset/">bitset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ccpc/">ccpc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cf/">cf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cousera/">cousera</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs序/">dfs序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dp/">dp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hihocoder/">hihocoder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kdtree/">kdtree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/km算法/">km算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lca/">lca</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/matlab/">matlab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/polay计数/">polay计数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vector/">vector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图/">二分图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/位运算/">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分块/">分块</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前向星/">前向星</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/匈牙利算法/">匈牙利算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博弈/">博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/卡特兰数/">卡特兰数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/后缀数组/">后缀数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/周赛/">周赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/哈密顿/">哈密顿</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回文串/">回文串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/团/">团</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多校/">多校</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字典树/">字典树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并查集/">并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异或/">异或</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/扩展欧几里德算法/">扩展欧几里德算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/搜索/">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数位运算/">数位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新生赛/">新生赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树状数组/">树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/树链剖分/">树链剖分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧几里德算法/">欧几里德算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/欧拉回路/">欧拉回路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/比赛/">比赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/游戏/">游戏</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/瓶颈路/">瓶颈路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/百度之星/">百度之星</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/省赛/">省赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/线段树/">线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流/">网络流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网赛/">网赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/背包/">背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/背包问题/">背包问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/莫比乌斯/">莫比乌斯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/莫队算法/">莫队算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/蓝桥杯/">蓝桥杯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心/">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集合/">集合</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://voyage97.github.io/">Mr Kevin</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://open.163.com/ted/">TED-Talk</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://acm.split.hdu.edu.cn/">ACM-HDOJ</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://www.acmerblog.com/">ACM之家</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://hhmy.duoshuo.com/admin/">多说管理</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://www.wal8.com/upload/add.html">外链图床</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://netcn.console.aliyun.com/core/domain/list?spm=5176.200004.102.5.wPXnzm">域名管理</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://github.com/MOxFIVE/hexo-theme-yelee">本主题下载</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">锄禾日当午，不如coding苦。 对着C++，一调一下午。 调了一下午，bug还得补。 Bug刚补完，结构需重组。 Bug改不完，无言见列祖。</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Hippopmonkey</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/15029834412.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Hippopmonkey</a></h1>
            </hgroup>
            
            <p class="header-subtitle">每天都是一个起点，每天都有一点进步，每天都有一点收获!</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa 新浪微博" target="_blank" href="http://weibo.com/u/5255092020/home" title="新浪微博"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/#signin" title="知乎"></a>
                            
                                <a class="fa 豆瓣" target="_blank" href="https://www.douban.com/" title="豆瓣"></a>
                            
                                <a class="fa 简书" target="_blank" href="http://www.jianshu.com/" title="简书"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="標籤" friends="友情鏈接" about="關於我"/>
</nav>
      <div class="body-wrap"><article id="post-九大基础排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/09/01/九大基础排序算法/" class="article-date">
      <time datetime="2016-09-01T01:03:22.000Z" itemprop="datePublished">2016-09-01</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      十三种基础排序算法[置顶]
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/自用笔记/">自用笔记</a><a class="article-category-link" href="/categories/自用笔记/算法/">算法</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/函数/">函数</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/排序/">排序</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h1 id="基础排序算法分析与总结"><a href="#基础排序算法分析与总结" class="headerlink" title="基础排序算法分析与总结"></a>基础排序算法分析与总结</h1><h2 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p><strong>算法思想</strong>：<br>(1)将第i个记录插入到前面i-1个已经排序好的记录中<br>(2)插入过程为依次比较后移，直到找到比第i个记录小的数为止，插入。<br><a id="more"></a><br><img src="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329094816957-1860272498.jpg" alt=""><br><strong>算法实例</strong>：<br>待排序列｛48，62，35，77，55，14，35，98｝<br>A）｛48｝ 62 35 77 55 14 35 98<br>B）｛48 62｝ 35 77 55 14 35 98<br>C）｛35 48 62｝ 77 55 14 35 98<br>D）｛35 48 62 77｝ 55 14 35 98<br>E）｛35 48 55 62 77｝ 14 35 98<br>F）｛14 35 48 55 62 77｝ 35 98<br>G）｛14 35 35 48 55 62 77｝ 98<br>H）｛14 35 35 48 55 62 77 98｝<br>以下是用插入排序对30个元素的数组进行排序的动画：<br><img src="http://img.blog.csdn.net/20150606133020561" alt=""><br>对序列{6, 5, 3, 1, 8, 7, 2, 4}进行插入排序的实现过程如下<br><img src="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329095145504-1018443290.gif" alt=""><br>直接插入排序动画图：<br><img src="http://images2015.cnblogs.com/blog/739525/201603/739525-20160328201132394-577931661.gif" alt=""><br><strong>算法实现</strong>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">void insertsort(int a[])           //直接插入排序</div><div class="line">&#123;</div><div class="line">	int pre,key;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		key=a[i];</div><div class="line">		pre=i-1;</div><div class="line">		<span class="keyword">while</span>(pre&gt;=0&amp;&amp;a[pre]&gt;key)</div><div class="line">		&#123;</div><div class="line">			a[pre+1]=a[pre];</div><div class="line">			pre--;</div><div class="line">		&#125;</div><div class="line">		a[pre+1]=key;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	insertsort(a);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O（1）<br>2.平均时间复杂度：O（n²）<br>  最差情况：反序，需要移动n*(n-1)/2个元素 ，运行时间为O(n^2)。 　<br>  最好情况：正序，不需要移动元素，运行时间为O(n)．<br>3.稳定的排序算法<br>4.该排序与选择排序的区别是：选中已经排好序列的后一个数来进行插入操作，没有从未排序数中选择的过程<br>5.该排序与折半插入排序的区别：减少比较次数，直接插入排序为挨个比较，折半插入排序为二分比较，效率更高</p>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p><strong>算法思想</strong><br>与直接插入排序类似，只是通过二分查找找到需要插入的位置，直接插入，而非一个一个比较查找<br><strong>算法实例</strong><br><img src="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148493217649.jpg" alt=""><br>A）｛48｝ 62 35 77 55 14 35 98<br>B）｛48 62｝ 35 77 55 14 35 98<br>C）｛35 48 62｝ 77 55 14 35 98<br>D）｛35 48 62 77｝ 55 14 35 98<br>E）｛35 48 55 62 77｝ 14 35 98<br>F）｛14 35 48 55 62 77｝ 35 98<br>G）｛14 35 35 48 55 62 77｝ 98<br>H）｛14 35 35 48 55 62 77 98｝<br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">int low=0,high=9;</div><div class="line">void binsertsort(int a[])          //折半插入排序</div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		int key=a[i];</div><div class="line">		int low=0,high=i;</div><div class="line">		<span class="keyword">while</span>(low&lt;=high)</div><div class="line">		&#123;</div><div class="line">			int mid=(low+high)/2;</div><div class="line">			<span class="keyword">if</span>(a[mid]&lt;key)</div><div class="line">				low=mid+1;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				high=mid-1;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(int j=i;j&gt;=low+1;j--)</div><div class="line">			a[j]=a[j-1];</div><div class="line">		a[low]=key;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	binsertsort(a);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O（1）<br>2.平均时间复杂度：O（n²）<br>3.折半插入排序是一种稳定的排序算法<br>4.折半插入排序并没有改变时间复杂度，而是把比较次数的数量级降到了O（n*logn）<br>5.当n较大时 折半插入排序的比较次数要比直接插入排序的最差情况要好很多 但比其最好情况要差</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><strong>算法思想</strong><br>希尔排序法(缩小增量法) 属于插入类排序，是将整个无序列分割成若干小的子序列分别进行插入排序的方法。<br>把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>(1)插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。<br>(2)但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。<br><strong>算法实例</strong><br>假设有这样一组数[<strong>13</strong> <strong>14</strong> <strong>94</strong> <strong>33</strong> <strong>82</strong> <strong>25</strong> <strong>59</strong> <strong>94</strong> <strong>65</strong> <strong>23</strong> <strong>45</strong> <strong>27</strong> <strong>73</strong> <strong>25</strong> <strong>39</strong> <strong>10</strong>]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，<br>这样他们就应该看起来是这样：<br><strong>13</strong> <strong>14</strong> <strong>94</strong> <strong>33</strong> <strong>82</strong><br><strong>25</strong> <strong>59</strong> <strong>94</strong> <strong>65</strong> <strong>23</strong><br><strong>45</strong> <strong>27</strong> <strong>73</strong> <strong>25</strong> <strong>39</strong><br><strong>10</strong><br>然后我们对每列进行排序：<br><strong>10</strong> <strong>14</strong> <strong>73</strong> <strong>25</strong> <strong>23</strong><br><strong>13</strong> <strong>27</strong> <strong>94</strong> <strong>33</strong> <strong>39</strong><br><strong>25</strong> <strong>59</strong> <strong>94</strong> <strong>65</strong> <strong>82</strong><br><strong>45</strong><br>将上述四行数字，依序接在一起时我们得到：[<strong>10</strong> <strong>14</strong> <strong>73</strong> <strong>25</strong> <strong>23</strong> <strong>13</strong> <strong>27</strong> <strong>94</strong> <strong>33</strong> <strong>39</strong> <strong>25</strong> <strong>59</strong> <strong>94</strong> <strong>65</strong> <strong>82</strong> <strong>45</strong>].这时10已经移至正确位置了，然后再以3为步长进行排序：<br><strong>10</strong> <strong>14</strong> <strong>73</strong><br><strong>25</strong> <strong>23</strong> <strong>13</strong><br><strong>27</strong> <strong>94</strong> <strong>33</strong><br><strong>39</strong> <strong>25</strong> <strong>59</strong><br><strong>94</strong> <strong>65</strong> <strong>82</strong><br><strong>45</strong><br>排序之后变为：<br><strong>10</strong> <strong>14</strong> <strong>13</strong><br><strong>25</strong> <strong>23</strong> <strong>33</strong><br><strong>27</strong> <strong>25</strong> <strong>59</strong><br><strong>39</strong> <strong>65</strong> <strong>73</strong><br><strong>45</strong> <strong>94</strong> <strong>82</strong><br><strong>94</strong><br>最后以1步长进行排序（此时就是简单的插入排序了）。<br>希尔排序动画图：<br><img src="http://images2015.cnblogs.com/blog/739525/201603/739525-20160328205313363-2043878119.gif" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">//******************************希尔排序******************************</div><div class="line">void shellsort(int a[])</div><div class="line">&#123;</div><div class="line">	int j;</div><div class="line">	<span class="keyword">for</span>(int gap=n/2;gap&gt;0;gap/=2)</div><div class="line">		<span class="keyword">for</span>(int i=gap;i&lt;n;i++)</div><div class="line">		&#123;</div><div class="line">			int temp=a[i];</div><div class="line">			<span class="keyword">for</span>(j=i-gap;j&gt;=0&amp;&amp;a[j]&gt;temp;j-=gap)</div><div class="line">				a[j+gap]=a[j];</div><div class="line">			a[j+gap]=temp;</div><div class="line">		&#125;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	shellsort(a);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O（1）<br>2.时间复杂度：平均 O(n^1.5)或O(n^1.3)<br>　　　　　　　最好 O(n)<br>　　　　　　　最坏 O(n^2)<br>3.希尔排序是一种不稳定的排序算法<br>4.希尔排序对于中等规模（n≤1000）的序列具有较高的效率，而且希尔排序算法简单，容易执行，因此很多排序应用程序都选用了希尔排序<br>5.关于增量d的取法，最初Shell提出取d=n[n/2]–下取整，再取d=d=n[n/2]，直到d=1为止。<br>  该思路的缺点是，奇数位置的元素在最后一步才会与偶数位置的元素进行比较，使得希尔排序效率降低<br>  后来Knuth提出d=[n/3]+1<br>  本文代码采用的是d=n[n/2]的增量取法</p>
<h2 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>算法思想</strong><br>冒泡排序通过重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来，直到没有再需要交换的元素为止（对n个项目需要O(n^2)的比较次数）<br>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。<br>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。　<br>2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>3.针对所有的元素重复以上的步骤，除了最后一个。<br>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。　<br><strong>算法实例</strong><br>对序列{6, 5, 3, 1, 8, 7, 2, 4}进行冒泡排序的实现过程如下<br><img src="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329100443676-1647340243.gif" alt=""><br>冒泡排序动画如下:<br><img src="http://img.blog.csdn.net/20150606135844053" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">void exchange(int &amp;a,int &amp;b)</div><div class="line">&#123;</div><div class="line">	a=a^b;</div><div class="line">	b=a^b;</div><div class="line">	a=a^b;</div><div class="line">&#125;</div><div class="line">//*****************************冒泡******************************</div><div class="line">void <span class="function"><span class="title">bubble</span></span>()</div><div class="line">&#123;</div><div class="line">	int *b=a;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;n;i++)</div><div class="line">		<span class="keyword">for</span>(int j=0;j&lt;n-i;j++)</div><div class="line">			<span class="keyword">if</span>(a[j]&gt;a[j+1])</div><div class="line">				exchange(b[j],b[j+1]);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;b[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	bubble();</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O（1）<br>2.时间复杂度：  平均O (n²)<br>                最好O(n)<br>3.冒泡排序是一种稳定的排序算法<br>4.冒泡两层for循环外层表示进行n-1趟排序 内层表示每趟要进行n-i次比较<br>5.冒泡排序的改进：<br>思路：增加一个标识位 当某一趟冒泡排序没有进行元素交换 即元素已经有序时 冒泡结束<br>核心部分改为以下即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">int flag=1;</div><div class="line"><span class="keyword">for</span>(int i=1;i&lt;=n-1&amp;&amp;flag;i++)</div><div class="line">	<span class="keyword">for</span>(int j=0;j&lt;n-1;j++)</div><div class="line">	&#123;</div><div class="line">		flag=0;</div><div class="line">		<span class="keyword">if</span>(a[j]&gt;=a[j]+1)</div><div class="line">		&#123;</div><div class="line">			a[j]=a[j]^a[j+1];</div><div class="line">			a[j+1]=a[j]^a[j+1];</div><div class="line">			a[j]=a[j]^a[j+1];</div><div class="line">			flag=1;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>算法思想</strong><br>快速排序（Quicksort）是对冒泡排序的一种改进，又称划分交换排序（partition-exchange sort。<br>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）<br>1.从数列中挑出一个元素，称为”基准”（pivot）<br>2.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列<br>的中间位置。这个称为分区（partition）操作。<br>3.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序<br><strong>算法实例</strong><br><img src="http://img.blog.csdn.net/20160519164311224" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">int low=0,high=9;</div><div class="line">//*****************************快排(int)****************************</div><div class="line">int getmid(int list[],int low,int high)</div><div class="line">&#123;</div><div class="line">	int temp=list[low];</div><div class="line">	<span class="keyword">while</span>(low&lt;high)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">while</span>(low&lt;high&amp;list[high]&gt;=temp)</div><div class="line">			high--;</div><div class="line">		list[low]=list[high];</div><div class="line">		<span class="keyword">while</span>(low&lt;high&amp;&amp;list[low]&lt;=temp)</div><div class="line">			low++;</div><div class="line">		list[high]=list[low];</div><div class="line">	&#125;</div><div class="line">	list[low]=temp;</div><div class="line">	<span class="built_in">return</span> low;</div><div class="line">&#125;</div><div class="line">void quicksort(int a[],int low,int high)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(low&lt;high)</div><div class="line">	&#123;</div><div class="line">		int mid=getmid(a,low,high);</div><div class="line">		quicksort(a,low,mid-1);</div><div class="line">		quicksort(a,mid+1,high);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	quicksort(a,low,high);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.平均空间复杂度：O（logn）<br>2.平均时间复杂度：O（n<em>logn）<br>                  最差：O(n²)<br>                  最好：O(n</em>logn)<br>3.快排是一种不稳定的排序算法<br>4.当数据趋近于无序时 快排的时间复杂度最优<br>  当数据趋近于有序有 快排就会退化为一般的排序算法 时间复杂度退化为O(n²)<br>5.快排使用了递推 因此需要栈的辅助 空间复杂度较别的算法略高<br>6.优化（一）<br>  枢轴的选取十分重要 选取的枢轴越接近中间值 算法的效率越高<br>  正常算法的枢轴选取为数组的首元素<br>  因此具体优化可以：每次选取避免选取到最值 可采用取平均值的方法求得尽可能靠中间的值<br>7.优化二（二）<br>  获取枢轴的一般步骤为：<br>  （1）确定枢轴<br>  （2）从最高位开始找到第一个小于枢轴的数 与枢轴交换<br>  （3）从最低位开始找到第一个大于枢轴的数 与枢轴交换<br>  （4）直到high=low停止 实现枢轴的坐标均小于它 右边均大于它<br>   针对两次交换操作 可以做如下优化：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list[low]=list[high];  //temp为枢轴</div><div class="line">list[high]=list[low];</div><div class="line">list[low]=temp;       //当low=high时退出<span class="keyword">while</span>循环执行该步</div></pre></td></tr></table></figure></p>
<p>   如上优化可以避免进行两次交换操作<br>   哪怕使用空间复杂度为1的位运算来交换两个数也会额外增加代码书写难度</p>
<h2 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p><strong>算法思想</strong><br>每趟在n-i+1个记录中选取最小的关键字作为有序列中的第i个记录<br><strong>算法实例</strong><br>待排序列｛<strong>48</strong>，<strong>62</strong>，<strong>35</strong>，<strong>77</strong>，<strong>55</strong>，<strong>14</strong>，<strong>35</strong>，<strong>98</strong>｝<br>A）<strong>14</strong>｛<strong>62</strong> <strong>35</strong> <strong>77</strong> <strong>55</strong> <strong>48</strong> <strong>35</strong> <strong>98</strong>｝<br>B）<strong>14</strong> <strong>35</strong>｛<strong>62</strong> <strong>77</strong> <strong>55</strong> <strong>48</strong> <strong>35</strong> <strong>98</strong>｝<br>C）<strong>14</strong> <strong>35</strong> <strong>35</strong>｛<strong>77</strong> <strong>55</strong> <strong>48</strong> <strong>62</strong> <strong>98</strong>｝<br>D）<strong>14</strong> <strong>35</strong> <strong>35</strong> <strong>48</strong>｛<strong>55</strong> <strong>77</strong> <strong>62</strong> <strong>98</strong>｝<br>E）<strong>14</strong> <strong>35</strong> <strong>35</strong> <strong>48</strong> <strong>55</strong>｛<strong>77</strong> <strong>62</strong> <strong>98</strong>｝<br>F）<strong>14</strong> <strong>35</strong> <strong>35</strong> <strong>48</strong> <strong>55</strong> <strong>62</strong>｛<strong>77</strong> <strong>98</strong>｝<br>G）<strong>14</strong> <strong>35</strong> <strong>35</strong> <strong>48</strong> <strong>55</strong> <strong>62</strong> <strong>77</strong>｛<strong>98</strong>｝<br>H）<strong>14</strong> <strong>35</strong> <strong>35</strong> <strong>48</strong> <strong>55</strong> <strong>62</strong> <strong>77</strong> <strong>98</strong><br>选择排序的比较过程如下：<br><img src="http://img.blog.csdn.net/20150606134600369" alt=""><br>动画效果如下：<br><img src="http://img.blog.csdn.net/20150606134622646" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void selectsort(int a[],int n)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n-1;i++)</div><div class="line">	&#123;</div><div class="line">		int k=i;</div><div class="line">		<span class="keyword">for</span>(int j=i+1;j&lt;=n;j++)</div><div class="line">			<span class="keyword">if</span>(a[j]&lt;a[k])</div><div class="line">				k=j;</div><div class="line">		<span class="keyword">if</span>(k!=i)</div><div class="line">			swap(r[i],r[k]);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O（1）<br>2.时间复杂度：O(n²)<br>3.简单选择排序是不稳定的排序算法</p>
<h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><p><strong>算法思想</strong><br>又成锦标赛排序<br>基本思想是先把待排序的n个记录的关键字两两比较 取出最小者 然后在[n/2]个较小者中 采用同样的方法进行比较 直至选出最小的关键字为止<br>这一过程可以用一颗满二叉树来表示 不满时的结点用正无穷来填补<br>重复以上操作 直到所有的关键字全被取出为止<br><strong>算法实例</strong><br><img src="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148493184991.png" alt=""><br><strong>算法分析</strong><br>1.时间复杂度为：O（n*logn）</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>算法思想</strong><br>堆是一种数据结构，最好的理解堆的方式就是把堆看成一棵完全二叉树，这个完全二叉树满足任何一个非叶节点的值，都不大于（或不小于）其左右孩子节点的值。<br>若父亲大孩子小，则这样的堆叫做大根堆；若父亲小孩子大，这样的堆叫做小根堆。根据堆的定义，其根节点的值是最大（或最小），因此将一个无序序列调整为一个堆，<br>就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1个，对新的无序序列重<br>复这样的操作，就实现了序列排序。堆排序中最关键的操作是将序列调整为堆，整个排序的过程就是通过不断调整使得不符合堆定义的完全二叉树变为符合堆定义的完全<br>二叉树的过程。<br>堆排序执行过程（大根堆）：<br>（1）从无序序列所确定的完全二叉树的第一个非叶子节点开始，从右至左，从下至上，对每个节点进行调整，最终将得到一个大根堆。<br>将当前节点（a）的值与其孩子节点进行比较，如果存在大于a值的孩子节点，则从中选出最大的一个与a交换。<br>当a来到下一层的时候重复上述过程，直到a的孩子节点值都小于a的值为止。<br>（2）将当前无序序列中第一个元素，在树中是根节点（a）与无序序列中最后一个元素（b）交换。a进入有序序列，到达最终位置，<br>无序序列中元素减少1个，有序序列中元素增加1个，此时只有节点b可能不满足堆的定义，对其进行调整。<br><strong>算法实例</strong><br>初始化动画如下：<br><img src="http://img.blog.csdn.net/20150606133355179" alt=""><br>堆排序动画如下：<br><img src="http://img.blog.csdn.net/20150606133543747" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">void exchange(int &amp;a,int &amp;b)</div><div class="line">&#123;</div><div class="line">	a=a^b;</div><div class="line">	b=a^b;</div><div class="line">	a=a^b;</div><div class="line">&#125;</div><div class="line">//******************************堆排序******************************</div><div class="line">void heapsort(int b[])</div><div class="line">&#123;</div><div class="line">	creat_heap(b);</div><div class="line">	<span class="keyword">for</span>(int i=n;i&gt;=1;i--)</div><div class="line">	&#123;</div><div class="line">		exchange(b[1],b[i]);</div><div class="line">		sift(b,1,i-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">void creat_heap(int b[])</div><div class="line">&#123;</div><div class="line">	<span class="keyword">for</span>(int i=n/2;i&gt;=1;i--)</div><div class="line">		sift(b,i,n);</div><div class="line">&#125;</div><div class="line">void sift(int b[],int k,int m)</div><div class="line">&#123;</div><div class="line">	int t=b[k];</div><div class="line">	bool flag=<span class="literal">false</span>;</div><div class="line">	int i=k,j=2*i;</div><div class="line">	<span class="keyword">while</span>(j&lt;=m&amp;&amp;!flag)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b[j]&lt;b[j+1]&amp;&amp;j+1&lt;=m)</div><div class="line">			j=j+1;</div><div class="line">		<span class="keyword">if</span>(t&gt;=b[j])</div><div class="line">			flag=<span class="literal">true</span>;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			b[i]=b[j];</div><div class="line">			i=j;</div><div class="line">			j=2*i;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	b[i]=t;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	int b[100];</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</div><div class="line">		cin&gt;&gt;b[i];</div><div class="line">	heapsort(b);</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</div><div class="line">		cout&lt;&lt;b[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O（1）<br>2.时间复杂度为：O（n<em>logn）<br>  最差时间复杂度：O（n</em>logn）<br>3.堆排序是一种不稳定的排序算法<br>4.由于堆排序的最差时间复杂度依然为O（n*logn） 这是堆排序最大的优点<br>5.它并不适用于n个数较小的情况 对于n较大的文件非常有效 如从1000000个记录中选出前10个最小的 这种情况用堆排序最好<br>6.堆中定义的三种操作<br>  （1）创建大根堆（Build_Max_Heap）：将堆所有数据重新排序<br>  （2）大根堆调整（Max_Heapify）：将堆的节点作调整，使得子节点永远小于父节点<br>  （3）堆排序（HeapSort）：移除位在第一个数据的根节点，并做大根堆调整的递归运算<br>7.由于堆排序运用了子节点与父节点的关系 所以数组最好从a[1]开始存储数据 方便运算<br>8.堆的存储：<br><img src="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148492044202.png" alt=""></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>算法思想</strong><br>其核心就是“两两归并”，首先将原始序列看成每个只含有单独1个元素的子序列，两两归并，形成若干有序二元组，则第一趟归并排序结束，再将这个序列看成若干个<br>二元组子序列，继续两两归并，形成若干有序四元组，则第二趟归并排序结束，以此类推，最后只有两个子序列，再进行一次归并，即完成整个归并排序。<br>若将两个有序表合并成一个有序表，称为二路归并。<br><strong>算法实例</strong><br><img src="http://img.blog.csdn.net/20160517150920429" alt=""><br><img src="http://img.my.csdn.net/uploads/201210/29/1351511800_4371.jpg" alt=""><br>归并排序动画如下：<br><img src="http://img.blog.csdn.net/20150606133653347" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">void Merge_array(int a[],int low,int mid,int high,int temp[])</div><div class="line">&#123;</div><div class="line">	int i=low,m=mid,j=mid+1,h=high;</div><div class="line">	int k=0;</div><div class="line">	<span class="keyword">while</span>(i&lt;=m&amp;&amp;j&lt;=h)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(a[i]&lt;=a[j])</div><div class="line">			temp[k++]=a[i++];</div><div class="line">		<span class="keyword">else</span></div><div class="line">			temp[k++]=a[j++];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(i&lt;=m)</div><div class="line">		temp[k++]=a[i++];</div><div class="line">	<span class="keyword">while</span>(j&lt;=h)</div><div class="line">		temp[k++]=a[j++];</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;k;i++)</div><div class="line">		a[low+i]=temp[i];</div><div class="line">&#125;</div><div class="line">void Merge_sort(int a[],int low,int high,int temp[])</div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(low&lt;high)</div><div class="line">	&#123;</div><div class="line">		int mid=(low+high)/2;</div><div class="line">		Merge_sort(a,low,mid,temp);</div><div class="line">		Merge_sort(a,mid+1,high,temp);</div><div class="line">		Merge_array(a,low,mid,high,temp);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	int temp[10];</div><div class="line">	Merge_sort(a,low,high,temp);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O（n）<br>2.时间复杂度为：O（n*logn）<br>3.归并排序是一种稳定的排序算法<br>4.归并排序运用了二分递归的方法实现两两排序 把两个子表合成一个总表的方法类似于单链表的合并操作<br>5.参加网上测试样例：对于5万个随机数 归并排序几乎不需要时间 对于20万个随机数 仅耗时62ms 而快排需要78ms<br><img src="http://cfmfa.img48.wal8.com/img48/553098_20160720105230/148492107059.png" alt=""></p>
<h2 id="三大线性时间排序算法"><a href="#三大线性时间排序算法" class="headerlink" title="三大线性时间排序算法"></a>三大线性时间排序算法</h2><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p><strong>算法思想</strong><br>计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。<br>计数数组C用来统计比数组中每个数字小的数有多少个 例如有个17个小于x的元素 那么C[x]=17 x可直接放在第18个位置<br>1.统计数组A中每个值A[i]出现的次数，存入C[A[i]]<br>2.从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就代表了数组A中小于等于A[i]的元素个数<br>3.反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]项（即B[C[A[i]] - 1]），每放一个元素就将C[A[i]]递减<br><strong>算法实例</strong><br>下图给出了对{4, 1, 3, 4, 3}进行计数排序的简单演示过程<br><img src="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329112223504-109981973.gif" alt=""><br>再给出一个实现图解：<br><img src="http://images.cnitblog.com/i/175043/201407/140246168184432.jpg" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">//******************************计数排序****************************</div><div class="line">void Counting_sort(int a[])</div><div class="line">&#123;</div><div class="line">	int b[11],c[100];</div><div class="line">	memset(c,0,sizeof(c));</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		c[a[i]]++;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;100;i++)</div><div class="line">		c[i]+=c[i-1];</div><div class="line">	<span class="keyword">for</span>(int i=n-1;i&gt;=0;i--)</div><div class="line">	&#123;</div><div class="line">		b[c[a[i]]]=a[i];</div><div class="line">		c[a[i]]--;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</div><div class="line">		cout&lt;&lt;b[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	Counting_sort(a);</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度:O(n+k)<br>2.时间复杂度：O(n+k)–k为数据的范围<br>  平均时间复杂度：O(n+k)<br>  最差时间复杂度：O(n+k)<br>3.计数排序是一种稳定的排序算法<br>4.如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。<br>  但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。<br>  其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。<br>5.计数排序的时间复杂度和空间复杂度取决于数组A的数据范围(等于A中元素的最大值与最小值的差加上1)，因此对于数据范围很大的数组，计数排序需要大量时间<br>  和内存 所以计数排序并不适用与数据范围很大的数组<br>6.计数排序经常用作基数排序算法的一个子过程，其稳定性对于基数排序的正确性来说非常关键<br>7.计数排序不是比较排序，排序的速度快于任何比较排序算法</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><strong>算法思想</strong><br>工作原理是将数组分解到有限数量的桶里，每个桶再分别进行排序。桶内排序有可能使用其他排序算法或是以递归的方式继续使用桶排序<br>1.在数组中查找数值的最大值和最小值；<br>2.初始化一个数组当作空桶，长度为 (MaxValue - MinValue + 1)。<br>3.遍历被排序数组，并把数值逐个放入对应的桶中。<br>4.对每个不是空的桶进行排序。<br>5.从不是空的桶里把数值再放回原来的数组中。<br><strong>算法实例</strong><br>下图给出了对{29, 25, 3, 49, 9, 37, 21, 43}进行桶排序的简单演示过程<br><img src="http://images.cnitblog.com/i/175043/201407/141242228816031.png" alt=""><br><img src="http://images.cnitblog.com/i/175043/201407/141242472874543.png" alt=""><br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line"><span class="comment">#include&lt;cstring&gt;</span></div><div class="line"><span class="comment">#include&lt;algorithm&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">//******************************桶排序******************************</div><div class="line">//*****快排的源码已给出 不再复制</div><div class="line">struct node</div><div class="line">&#123;</div><div class="line">	int data[10];</div><div class="line">	int count;</div><div class="line">&#125;;</div><div class="line">void Bucket_sort(int a[])</div><div class="line">&#123;</div><div class="line">	int Max=a[0],M<span class="keyword">in</span>=a[0],num;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		Max=max(Max,a[i]);</div><div class="line">		M<span class="keyword">in</span>=min(M<span class="keyword">in</span>,a[i]);</div><div class="line">	&#125;</div><div class="line">	num=(Max-M<span class="keyword">in</span>+1)/10+1;</div><div class="line">	struct node *p;</div><div class="line">	p=new struct node[num];</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;num;i++)</div><div class="line">		p[i].count=0;</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">	&#123;</div><div class="line">		int k=(a[i]-M<span class="keyword">in</span>+1)/10;</div><div class="line">		p[k].data[p[k].count]=a[i];</div><div class="line">		p[k].count++;</div><div class="line">	&#125;</div><div class="line">	int pos=0;</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;num;i++)</div><div class="line">	&#123;</div><div class="line">		quicksort(p[i].data,0,p[i].count-1);</div><div class="line">		<span class="keyword">for</span>(int j=0;j&lt;p[i].count;j++)</div><div class="line">			a[pos++]=p[i].data[j];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	Bucket_sort(a);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度：O(k×n)<br>2.时间复杂度：O(n+k)  （k=N*(logN-logM)–N为待排数据 M为桶的数量）<br>  平均时间复杂度：O(n+k)<br>  最差时间复杂度：O(n²)<br>3.桶排序是一种稳定的排序算法<br>4.当要被排序的数组中的数值是均匀分布时 桶排序的运行时间为线性时间O(n)。桶排序不是比较排序，它不受O(nlogn)下界的影响<br>5.在桶排序中找到正确的映射函数f(k)是关键 他可以把N个数据尽可能平均的分配到M个桶中<br>  其作用就相当于快排中的划分 希尔排序中的子序列 归并排序中的子问题 已经把大量数据分割成了基本有序的数据块<br>  例如上述图解的映射函数为f(k)=k/10<br>6.每个桶中可以根据情况使用各种排序函数 本文使用的是快排 也可以使用计数排序 堆排等等<br>7.桶排序算是计数排序的一种改进和推广 但是网上有许多资料把计数排序和桶排序混为一谈 其实桶排序要比计数排序复杂许多<br>8.代码中的结构体模拟了vector的作用 算出最大值-最小值后使用指针p动态分配空间 使得空间消耗最优</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>算法思想</strong><br>基数排序又是一种和前面排序方式不同的排序方式 基数排序不需要进行记录关键字之间的比较 基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法<br>所谓的多关键字排序就是有多个优先级不同的关键字 比如说成绩的排序 如果两个人总分相同 则语文高的排在前面 语文成绩也相同则数学高的排在前面<br>如果对数字进行排序 那么个位、十位、百位就是不同优先级的关键字 如果要进行升序排序 那么个位、十位、百位优先级一次增加<br>基数排序是通过多次的收分配和收集来实现的 关键字优先级低的先进行分配和收集<br>原理是将整数值按相同的有效位进行分组，然后在有效位区间内进行排序<br>1.获得值的最右侧的最小的位。<br>2.根据该位的值将数组内的元素值进行分组，但仍然保持元素的顺序。(以此来保持算法稳定性)<br>3.重复上述分组过程，直到所有的位都已被处理。<br><strong>算法实例</strong><br>下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程<br><img src="http://images2015.cnblogs.com/blog/739525/201603/739525-20160329112725566-1371714328.jpg" alt=""><br>再给出链式基数排序的实现过程<br><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305151241455-435533779.png" alt=""><br><img src="http://images2015.cnblogs.com/blog/735119/201603/735119-20160305151315580-1475685491.png" alt=""><br>数排序中可以选择采用<br>最低有效位基数排序(LSD Radix Sort：Least Significant Digit Radix Sort)或最高有效位基数排序(MSD Radix Sort：Most Significant Digit Radix Sort)<br>LSD 的排序方式由值的最低位也就是最右边开始,而 MSD 则相反 由值的最高位也就是最左边开始<br><img src="http://images.cnitblog.com/i/175043/201407/141258384434292.png" alt=""><br>但由于MSD比LDS复杂 所以一般采用从低位开始排序的算法<br>例如，如下这个无序的数列需要排序：<br>　　170, 45, 75, 90, 802, 2, 24, 66<br>使用 LSD 方式从最低位开始（个位）排序的结果是：<br>　　170, 90, 802, 2, 24, 45, 75, 66<br>再继续从下一位（十位）继续排序的结果是：<br>　　802, 2, 24, 45, 66, 170, 75, 90<br>再继续从下一位（百位）继续排序的结果是：<br>　　2, 24, 45, 66, 75, 90, 170, 802<br><strong>算法实现</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">//******************************基数排序****************************</div><div class="line"><span class="comment">#include&lt;iostream&gt;</span></div><div class="line"><span class="comment">#include&lt;cstring&gt;</span></div><div class="line"><span class="comment">#include&lt;vector&gt;</span></div><div class="line"><span class="comment">#include&lt;algorithm&gt;</span></div><div class="line">using namespace std;</div><div class="line"><span class="comment">#define n 10</span></div><div class="line">int a[10]=&#123;10,43,13,0,90,44,67,23,16,88&#125;;</div><div class="line">void Radix_sort(int a[])</div><div class="line">&#123;</div><div class="line">	int Max=a[0],count=0;</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		Max=max(Max,a[i]);</div><div class="line">	<span class="keyword">while</span>(Max&amp;10)</div><div class="line">	&#123;</div><div class="line">		Max/=10;</div><div class="line">		count++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span>(int i=1;i&lt;=count;i++)</div><div class="line">	&#123;</div><div class="line">		int k=0;</div><div class="line">		vector&lt;int&gt;v[10];</div><div class="line">		<span class="keyword">for</span>(int j=0;j&lt;n;j++)</div><div class="line">		&#123;</div><div class="line">			int flag=(int)pow(10.0,count-1);</div><div class="line">			int temp=(a[j]/flag)%10;</div><div class="line">			v[temp].push_back(a[j]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(int j=0;j&lt;10;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(!v[j].size())</div><div class="line">				<span class="built_in">continue</span>;</div><div class="line">			quicksort(v[j],0,v[j].size()-1);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(int j=0;j&lt;10;j++)</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">if</span>(!v[j].size())</div><div class="line">				<span class="built_in">continue</span>;</div><div class="line">			<span class="keyword">for</span>(int m=0;m&lt;v[j].size();m++)</div><div class="line">				a[k++]=v[j][m];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">int <span class="function"><span class="title">main</span></span>()</div><div class="line">&#123;</div><div class="line">	Radix_sort(a);</div><div class="line">	<span class="keyword">for</span>(int i=0;i&lt;n;i++)</div><div class="line">		cout&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</div><div class="line">	cout&lt;&lt;endl;</div><div class="line">	<span class="built_in">return</span> 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>算法分析</strong><br>1.空间复杂度:O(d×n)<br>2.时间复杂度:O(d×n)<br>3.基数排序是一种稳定的排序算法<br>4.基数排序的时间复杂度是O(n*dn)，其中n是排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(nlogn)，dn的大小取决于数字位的选择(比如比特位数)<br>  和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。<br>5.由于整数也可以表达字符串(比如名字或日期)和特定格式的浮点数，所以基数排序并不是只能用于整数排序<br>　如果考虑和比较排序进行对照 基数排序的形式复杂度虽然不一定更小 但由于不进行比较 因此其基本操作的代价较小 而且如果适当的选择基数<br>　dn一般不大于logn 所以基数排序一般要快过基于比较的排序 比如快速排序<br>6.基数排序类似于桶排序的思想 把数字按照位数放到10个桶中 每个桶中可以使用计数排序 因为在数据量较小时计数排序具有较高的效率<br>7.由于分块(桶)的数量是确定 所以可以使用vector来动态在每个桶中存放数字 即较少了内存消耗也减少了书写难度</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1</strong>.<strong>稳定性</strong><br>指待排序的序列中有两个或两个以上相同的项，在排序前和排序后看这些相同项的相对<strong>位置</strong>有没有发生<strong>变化</strong>，如果没有发生变化，即该排序方法是稳定的，<br>如果发生变化，则说该排序方法是不稳定的。<br><strong>2</strong>.在是三种排序算法中<br>稳定：<strong>直接插入排序</strong> <strong>折半插入排序</strong> <strong>冒泡排序</strong> <strong>归并排序</strong> <strong>基数排序</strong>  <strong>计数排序</strong> <strong>桶排序</strong><br>不稳定：<strong>希尔排序</strong>  <strong>快速排序</strong> <strong>简单选择排序</strong> <strong>堆排序</strong><br>即除了“<strong>快些（希）选堆</strong>”以外 其余都是稳定的排序算法<br><strong>3</strong>.经过一趟排序能够保证一个元素到达最终位置的是<strong>冒泡排序</strong>、<strong>快速排序</strong>、<strong>简单选择排序</strong>、<strong>堆排序</strong><br><strong>4</strong>.元素比较次数和原始序列无关的是<strong>简单选择排序</strong>、<strong>折半插入排序</strong>。<br><strong>5</strong>.排序趟数和原始序列有关的是<strong>交换类排序</strong>（<strong>冒泡排序</strong> <strong>快速排序</strong>）。<br><strong>6</strong>.<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>的平均时间为O(nlogn) <strong>希尔排序</strong>复杂度为O(n^1.3)或O(n^1.5)。<br><strong>7</strong>.对于<strong>选择排序</strong> 给定含n个元素的输入序列 任何比较排序在<strong>最坏情况</strong>下都需要Ω(nlogn)次比较来进行排序。<br>  <strong>归并排序</strong>和<strong>堆排序</strong>在最坏情况下达到上界O(nlogn) 它们都是渐进最优的排序算法 <strong>快速排序</strong>在平均情况下达到上界 O(nlogn)。<br>  而三种<strong>线性时间排序算法</strong>（<strong>基数排序</strong> <strong>计数排序</strong> <strong>桶排序</strong>）将突破O(nlogn)的下界 以线性时间运行<br><strong>8</strong>.三种<strong>线性时间排序算法</strong>是非比较排序 在特定条件下速度快过所有<strong>比较排序</strong><br><strong>9</strong>.没有最优的排序算法 根据数据的特性以及大小选择合适的排序算法才是关键<br><strong>10</strong>.最后总结下几种较优排序算法的实用情况：<br><strong>选择排序</strong><br>　<strong>直接插入排序</strong>：在数据基本有序时有较高的性能<br>　<strong>希尔排序</strong>：在中等数据量规模(n&lt;1000)具有较高的效率 但不稳定<br>　<strong>快排排序</strong>: 在数据量较大且数据趋于无序时具有较高效率 但不稳定且过多递归容易爆内存<br>　<strong>堆排序</strong>：  适用于数据量非常大的情况 最差时间复杂度依然为O(n×logn) 这是堆排序最大的优点 但不稳定<br>　<strong>归并排序</strong>：和前三种排序算法不同的是归并排序是一种稳定的排序算法 且综合性能很强 在要求稳定性时优先使用归并排序<br><strong>非选择排序</strong><br>　<strong>计数排序</strong>: 适用于数据范围较小的情况 线性时间O(n)运行 稳定 但耗空间较大<br>　<strong>桶排序</strong>：  适用于数据是均匀分布的情况 线性时间O(n)运行 稳定 但映射函数的选择对性能的影响巨大<br>　<strong>基数排序</strong>：线性时间O(n)运行 稳定 但数据的位数过大时不宜使用</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文標題:</span><a href="/2016/09/01/九大基础排序算法/">十三种基础排序算法[置顶]</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主頁">Hippopmonkey</a></p>
        <p><span>發布時間:</span>2016-09-01, 09:03:22</p>
        <p><span>最後更新:</span>2017-01-21, 13:15:43</p>
        <p>
            <span>原始鏈接:</span><a class="post-url" href="/2016/09/01/九大基础排序算法/" title="十三种基础排序算法[置顶]">http://xuboming8.github.io/2016/09/01/九大基础排序算法/</a>
            <span class="copy-path" data-clipboard-text="原文: http://xuboming8.github.io/2016/09/01/九大基础排序算法/　　作者: Hippopmonkey" title="點擊複製文章鏈接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>許可協議:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"姓名標示-非商業性-相同方式分享 4.0 國際"</a> 轉載請保留原文鏈接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2016/09/01/atoi与itoa函数介绍/">
                    atoi与itoa函数介绍
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2016/08/30/DP问题专题四-背包延伸/">
                    DP问题专题四 背包延伸
                </a>
            </div>
        
    </nav>

  
</article>

    
    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目錄</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础排序算法分析与总结"><span class="toc-number">1.</span> <span class="toc-text">基础排序算法分析与总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#插入类排序"><span class="toc-number">1.1.</span> <span class="toc-text">插入类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接插入排序"><span class="toc-number">1.1.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#折半插入排序"><span class="toc-number">1.1.2.</span> <span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#希尔排序"><span class="toc-number">1.1.3.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#交换类排序"><span class="toc-number">1.2.</span> <span class="toc-text">交换类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#冒泡排序"><span class="toc-number">1.2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速排序"><span class="toc-number">1.2.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择类排序"><span class="toc-number">1.3.</span> <span class="toc-text">选择类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单选择排序"><span class="toc-number">1.3.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树形选择排序"><span class="toc-number">1.3.2.</span> <span class="toc-text">树形选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆排序"><span class="toc-number">1.3.3.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序"><span class="toc-number">1.4.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三大线性时间排序算法"><span class="toc-number">1.5.</span> <span class="toc-text">三大线性时间排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#计数排序"><span class="toc-number">1.5.1.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桶排序"><span class="toc-number">1.5.2.</span> <span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基数排序"><span class="toc-number">1.5.3.</span> <span class="toc-text">基数排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隱藏目錄"  title="點擊按鈕隱藏或者顯示文章目錄">

    <script>
        yiliaConfig.toc = ["隱藏目錄", "顯示目錄", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"十三种基础排序算法[置顶]　| 臀臀柯基　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    
        <section class="youyan" id="comments">
    <script>
        var loadComment = function(){
            var d = document, s = d.createElement('script');
            s.src = 'http://v2.uyan.cc/code/uyan.js?uid=845569486';
            (d.head || d.body).appendChild(s);
        }
    </script>
    
    <script> loadComment(); </script>

    <div id="uyan_frame"></div>
</section>
    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2016/09/01/atoi与itoa函数介绍/" title="上一篇: atoi与itoa函数介绍">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2016/08/30/DP问题专题四-背包延伸/" title="下一篇: DP问题专题四 背包延伸">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/28/莫队专题/">莫队专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/kdtree专题/">kdtree专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/2017南宁网络赛/">2017南宁网络赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/22/hello-world/">First article about hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/19/网络流拓展四/">网络流拓展四</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/18/路径交集并拓展/">路径交集并拓展</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/18/2017青岛网络赛/">2017青岛网络赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/13/网络流拓展三/">网络流拓展三</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/11/lca相关/">lca相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/11/2017沈阳网络赛/">2017沈阳网络赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/09/2017新疆赛区网赛/">2017新疆赛区网赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/树链剖分专题3/">树链剖分专题3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/05/最短路相关/">最短路相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/01/2017广西邀请赛/">2017广西邀请赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/30/分块专题2/">分块专题2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/分块专题/">分块专题一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/muti多校-10/">muti多校-10</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/24/熟练剖分专题2/">树链剖分专题2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/23/树链剖分专题/">树链剖分专题1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/23/muti多校-9/">muti多校-9</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/2017ccpc网赛/">2017ccpc网赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/二分图总结/">二分图总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/dfs序专题/">dfs序专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/17/muti多校-7-8/">muti多校7 & 2017百度之星复赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/17/树状数组延伸/">树状数组延伸</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/图论-团专题/">图论-团专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/回文串专题/">回文串专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/cf-round428/">cf round428</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/2017百度之星预赛B/">2017百度之星预赛B</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/2017百度之星复赛A/">2017百度之星预赛A</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/muti多校-6/">muti多校-6</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/背包组合数相关/">背包组合数相关</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/09/muti多校-5/">muti多校-5</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/muti多校-4/">muti多校-4</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/07/atcoder-regular080/">atcoder regular080</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/06/2017百度之星-cf-edu26-D/">2017百度之星资格赛&&cf edu26-D</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/03/并查集/">并查集</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/02/multi多校-3/">multi多校-3</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/01/multi多校-2/">multi多校-2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/福建2017省赛/">福建2017省赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/hiho杂选/">hiho杂选</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/26/multi多校-1/">multi多校-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/25/cf-round-425/">cf round 425</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/24/hihocoder编程练习赛19/">hihocoder编程练习赛19</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/19/网络流拓展二/">网络流拓展二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/17/cf-edu25/">cf edu25</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/16/atcoder078regular/">atcoder078regular</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/15/cf-round-423/">cf round 423</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/14/cf-round-424/">cf round 424</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/上海大学oj比赛/">上海大学oj比赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/11/cf-round-422/">cf round 422</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/23/网络流拓展/">网络流拓展一</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/16/cf杂选-1/">cf杂选2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/13/NEUQ-ACM程序设计竞赛-团队赛/">NEUQ-ACM程序设计竞赛(团队赛)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/11/最小瓶颈路-变形/">最小瓶颈路&变形</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/11/浙工业之江学院比赛/">浙工业之江学院比赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/29/网络流专题/">网络流专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/29/百度之星专题/">百度之星专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/29/2017acm-final/">2017acm final</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/29/cf-at-hiho杂选二/">cf&at&hiho杂选二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/28/MST模板/">MST模板</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/25/Polay计数/">Polya计数</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/cf-at-杂选/">cf&at 杂选</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/cf杂选/">cf杂选</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/ccpc江苏省赛/">2017ccpc江苏省赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/2017-ccpc-wfin-女生赛/">2017 ccpc wfin-女生赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/博弈论/">博弈论</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/30/莫比乌斯反演/">莫比乌斯反演</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/26/杂题专选-二/">杂题专选-二</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/25/Bitset优化/">Bitset优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/06/线段树专题/">专题杂选</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/03/简单数论/">简单数论</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/28/容斥原理/">容斥原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/23/DP专题八-石子合并/">DP专题八--石子合并</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/17/DAG上的DP问题/">DAG上的DP问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/15/DP专题七-有关复杂集合/">DP专题七--有关复杂集合</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/12/dp专题六-树形dp/">dp专题六--树形dp</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/10/dp专题二/">dp基础专题五</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/07/贪心杂选/">贪心杂选</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/06/Machine-Learning-2/">Machine Learning-2</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/06/经典面试之——异或操作/">经典面试之——异或操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/03/贪心专题/">贪心专题-区间问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/01/欧拉通路-回路/">欧拉通路 回路</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/31/图论基础/">图论基础杂选</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/26/数位dp/">数位dp</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/18/Marchine-Learning/">Machine Learning</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/27/12-24-杭电校赛/">12-24 杭电校赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/11/12-11-哈理工团体新生赛/">12-11 哈理工团体新生赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/05/广工业新生赛/">广工业新生赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/图论-最短路专题/">图论-最短路专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/28/哈理工新人赛/">哈理工新生赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/22/蓝桥杯模拟赛/">蓝桥杯模拟赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/21/后缀数组四大基础应用/">后缀数组四大基础应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/16/二分图交叉染色法模版题/">二分图交叉染色法模版题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/15/11-13-周赛/">11-13 周赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/09/11-06-热身赛/">11-06 热身赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/09/RMQ问题/">RMQ问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/02/扩展欧几里德算法/">扩展欧几里德算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/02/10-30-热身赛/">10-30 热身赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/01/化繁为简：位运算/">化繁为简：位运算</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/31/字典树trie/">字典树trie</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/28/vector实现前向星/">vector实现前向星</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/26/10-23-热身赛/">10-23 热身赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/20/10-16-热身赛/">10-16 热身赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/03/神奇的树状数组/">神奇的树状数组</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/atoi与itoa函数介绍/">atoi与itoa函数介绍</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/01/九大基础排序算法/">十三种基础排序算法[置顶]</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/DP问题专题四-背包延伸/">DP问题专题四 背包延伸</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/DP问题专题三-完全·分组背包巩固/">DP问题专题三 完全·分组背包巩固</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/DP问题专题二-01背包专题/">DP问题专题二 01背包专题</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/DP问题专题一-Dynamic-Programming-背包入门/">DP问题专题一(Dynamic Programming) 背包入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/经典的搜索类游戏/">经典的搜索类游戏</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/深度优先搜索-DFS-与广度优先搜索-BFS/">深度优先搜索(DFS)与广度优先搜索(BFS)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/浅谈LIS算法-Longest-Increasing-Subsequence/">浅谈LIS算法(Longest Increasing Subsequence)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/Talking-with-Catalan/">Talking with Catalan</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/ACM-1023-1027-1058/">ACM 1023-1027 1058</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/ACM-1018-1022/">ACM 1018-1022</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/ACM-1013-1017/">ACM 1013-1017</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/ACM-1008-1012/">ACM 1008-1012</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/30/ACM-1002-1007/">ACM 1002-1007</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2016-2017 Hippopmonkey
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、簡潔且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="簡而不減 Hexo 雙欄博客主題  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到訪數"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本頁閱讀量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 3;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回頂部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看評論"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="轉到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
             post: ".article-entry a[href], .copyright a[href]", 
            
            
            
            
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>